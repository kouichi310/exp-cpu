### テスト作成の基本方針

このプロジェクトのテストは、「**1つの命令（または関連する機能）に対し、1つのテストスクリプトで、仕様を網羅的に検証する**」という方針で作成されています。各テストスクリプトは、特定の命令がCPUの仕様書通りに振る舞うことを、あらゆる側面から確認します。

---

### テスト作成ガイドライン

新しいテストスクリプトを作成する際は、以下の指針に従ってください。

#### 1. ファイルの命名と基本構造
* **命名規則**: `test_命令名.sh` の形式で新しいシェルスクリプトを作成します。（例: `test_adc.sh`）
* **基本構造のコピー**: 既存のテストスクリプト（例: `test_add.sh`）から、以下の部分をコピーして基本の骨格を作成します。
    * スクリプト冒頭の変数定義 (`#!/bin/sh`, `set -e`, `BIN`, `PASS_COUNT`など）
    * テスト実行用のヘルパー関数 `run_test()`
    * スクリプト末尾のテストサマリ表示と終了ステータス判定

#### 2. `run_test`関数によるテストケースの記述
各テストケースは `run_test` 関数を呼び出す形で記述します。

```sh
run_test "テストの目的（可読性の高い名前）" "
# シミュレータへのコマンド群
w 0 オペコード  # 1. 命令をメモリに書き込む
s pc 0        # 2. PCをセット
s acc 0x...   # 3. 事前条件となるレジスタ/フラグの値をセット
s ix 0x...
s cf 1
i             # 4. 命令を実行
d             # 5. 実行後のレジスタ/フラグ状態を表示
q             # 6. シミュレータを終了
" "期待される出力（grepパターン）"
```

* **第1引数**: テストの目的を簡潔に記述します。（例: `"ADD sets overflow flag"`）
* **第2引数**: シミュレータに与えるコマンドのシーケンスです。
* **第3引数**: `d`コマンドで表示された内容から、テストの成功を判断するための文字列（`grep`で使われる正規表現パターン）を指定します。`.*` を使うと、複数の条件を1行で検証できます。（例: `"acc=0x80.*vf=1"`）

#### 3. テスト項目の網羅（最も重要）
一つの命令に対して、以下の観点がすべてカバーされるように複数のテストケースを作成します。

* **全アドレッシングモードの検証**:
    仕様書に記載されているすべてのアドレッシングモードをテストします。
    * レジスタ指定 (`ACC`, `IX`)
    * 即値 (`d`)
    * 絶対アドレス（プログラム領域 `[d]` / データ領域 `(d)`）
    * IX修飾アドレス（プログラム領域 `[IX+d]` / データ領域 `(IX+d)`）

* **全ターゲットレジスタの検証**:
    命令が`ACC`と`IX`の両方を対象にできる場合、それぞれを宛先（destination）とするテストを作成します。

* **フラグの完全な検証**:
    * **フラグが変化するケース**: `CF`, `VF`, `NF`, `ZF`の各フラグが、仕様書通りに`1`になったり`0`になったりする条件をテストします。
    * **フラグが変化しないケース（副作用のなさ）**: `LD`や`IN`/`OUT`のように、算術フラグに影響を与えない命令については、「他のフラグが変化しないこと」を保証するテストを必ず作成します。

* **PC（プログラムカウンタ）の更新**:
    * 1語命令（1バイト）実行後に `PC` が `+1` されること。
    * 2語命令（2バイト）実行後に `PC` が `+2` されること。
