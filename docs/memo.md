以下では **教育用CPU本体** と **教育用CPUシミュレータ** の仕様をそれぞれ Markdown で簡潔にまとめました。

---

## 教育用 CPU 仕様

| 区分          | 内容                                                                                                                                                                                                                                     |
| ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **語長**      | 1 語 = **8 bit**                                                                                                                                                                                                                        |
| **レジスタ**    | - **ACC**（アキュムレータ）  <br>- **IX**（インデックスレジスタ）                                                                                                                                                                                           |
| **主記憶**     | - **512 byte** 内蔵メモリ（9 bit アドレス）<br>  - 0x000–0x0FF : **プログラム領域**<br> - 0x100–0x1FF : **データ領域**（プログラム実行不可）                                                                                                                             |
| **データ形式**   | - 基本は 8 bit 固定小数点<br>- 多倍長演算は 2 語, 3 語 … と拡張可能                                                                                                                                                                                         |
| **アドレス方式**  | 4 種類<br> 1. **レジスタ指定** (ACC / IX)<br> 2. **即値** `d`<br> 3. **絶対** `[d]` / `(d)`（プログラム / データ領域）<br> 4. **IX 修飾** `[IX+d]` / `(IX+d)`                                                                                                    |
| **命令セット概要** | - **データ移動** `LD / ST`<br>- **算術** `ADD, ADC, SUB, SBC, CMP`<br>- **論理** `AND, OR, EOR`<br>- **シフト/ローテート** `SRA/SLA/SRL/SLL, RRA/RLA/RRL/RLL`<br>- **分岐** `BA, BNZ, BGE …`（条件 16 種）<br>- **制御** `NOP, HLT, IN, OUT, RCF, SCF, JAL, JR`  |
| **フラグ**     | - **CF** (Carry/Borrow)<br>- **VF** (Overflow)<br>- **NF** (Negative)<br>- **ZF** (Zero)                                                                                                                                               |

---

## 教育用 CPU シミュレータ仕様

### 起動 & 対象 CPU

* 実行ファイルをそのまま起動。引数不要。
* プロンプト例: `CPU0,PC=0x0>` — `t` コマンドで **CPU0 / CPU1** をトグル&#x20;

### コマンド一覧（1 文字）

|        Cmd       | 機能             | 備考                                                      |
| :--------------: | -------------- | ------------------------------------------------------- |
|     `h` / `?`    | ヘルプ表示          | すべてのコマンド概要を一覧表示                                         |
|        `q`       | シミュレータ終了       | ―                                                       |
|        `t`       | 操作対象 CPU 切替    | CPU0 ↔ CPU1                                             |
|    `r <file>`    | プログラム／データを読み込み | `<file>` 内は 16 進バイト列。`.text` / `.data` ディレクティブで書込み先変更可  |
|        `d`       | レジスタ & フラグ表示   | ACC, IX, CF/VF/NF/ZF 等                                  |
|  `s <reg> <val>` | レジスタ／フラグ設定     | 16 進値で指定                                                |
|    `m [addr]`    | メモリ 16 byte 表示 | 引数なしで全域表示                                               |
| `w <addr> <val>` | メモリ書込み         | ―                                                       |
|        `i`       | **1 命令実行**     | PC が自動更新される                                             |
|     `c [bp]`     | 連続実行           | HLT か **500 命令** 実行、または **ブレークポイント** `bp` 到達で停止         |

> ※ コマンド実装は内部で `step()` を呼び出し 1 命令をシミュレートする。完成させるべき核心関数は `step()` 一つのみ&#x20;

### シミュレーション機能

1. **命令シミュレーション** — 教育用 CPU のマシン命令を忠実に実行
2. **コンソール機能** — 上記コマンドでプログラム投入・デバッグ・実行制御を行う&#x20;

---

### 参考: プログラム入力フォーマット例

```
a1 a2
.data 8c
c1 c2 c3 c4 c5
.text 50
20 4d 0f
```

* 0x000–0x001 ← `a1 a2`
* 0x18C–0x190 ← `c1 … c5`
* 0x050–0x052 ← `20 4d 0f`&#x20;

---

これで両 PDF に記載されている **仕様部分** を網羅的にまとめました。必要に応じて各表やリストを詳細化してご利用ください。


```
### 表 4 — 命令語コードとその機能（Markdown 版）

#### ■ 命令コード一覧

| 略記号               | **命令コード（1 語目）**<br>`b4 b3 b2 b1 b0 A B`<sup>†</sup> | B’（2 語目） | 機能概要               |
| ----------------- | --------------------------------------------------- | :------: | ------------------ |
| NOP               | `0 0 0 0 0 – –`                                     |     ×    | 何もしない              |
| HLT               | `0 0 0 0 1 1 –`                                     |     ×    | 停止                 |
| OUT               | `0 0 0 1 0 – –`                                     |     ×    | ACC → OBUF         |
| IN                | `0 0 0 1 1 – –`                                     |     ×    | IBUF → ACC         |
| RCF               | `0 0 1 0 0 – –`                                     |     ×    | 0 → CF             |
| SCF               | `0 0 1 0 1 – –`                                     |     ×    | 1 → CF             |
| LD                | `0 1 1 0 A B`                                       |     ○    | B → A              |
| ST                | `0 1 1 1 A B`                                       |     ◎    | A → B              |
| ADD               | `1 0 0 1 1 A B`                                     |     ○    | A＋B → A            |
| ADC               | `1 0 0 0 1 A B`                                     |     ○    | A＋B＋CF → A         |
| SUB               | `1 0 0 1 0 A B`                                     |     ○    | A－B → A            |
| SBC               | `1 0 0 0 0 A B`                                     |     ○    | A－B－CF → A         |
| CMP               | `1 1 1 1 1 A B`                                     |     ○    | A－B（結果のみ，格納なし）     |
| AND               | `1 1 1 0 1 A B`                                     |     ○    | A ∧ B → A          |
| OR                | `1 1 0 1 0 A B`                                     |     ○    | A ∨ B → A          |
| EOR               | `1 1 0 0 0 A B`                                     |     ○    | A ⊕ B → A          |
| S<sub>sm</sub> \* | `0 1 0 0 A 0 sm`                                    |     ×    | A を *shift* → A    |
| R<sub>sm</sub> \* | `0 1 0 0 A 1 sm`                                    |     ×    | A を *rotate* → A   |
| B<sub>bc</sub> ‡  | `0 0 0 1 1 bc`                                      |     ◎    | 条件成立時に B’ → PC     |
| JAL               | `0 0 0 0 1 0`                                       |     ◎    | PC＋2 → ACC，B’ → PC |
| JR                | `0 0 0 0 1 1`                                       |     ×    | ACC → PC           |

<sup>†</sup> 先頭 5 bit がオペコード，続く **A**（1 bit）, **B**（3 bit）がオペランド部。 <sup>\*</sup> *shift/rotate* の詳細は表 3 を参照。 <sup>‡</sup> **bc** は分岐条件フィールド（後述）。

---

#### ■ A フィールド（1 ビット）

|  A  | レジスタ |
| :-: | :--- |
|  0  | ACC  |
|  1  | IX   |

---

#### ■ B’ フィールド要否（2 語目）

|  記号 | 意味            |
| :-: | :------------ |
|  ×  | 不用            |
|  ○  | 不用 **または** 必要 |
|  ◎  | 必須            |

---

#### ■ sm : Shift Mode

| モード         | `sm` (2 bit) |
| :---------- | :----------: |
| RA (右算術)    |     `00`     |
| LA (左算術)    |     `01`     |
| RL (右ローテート) |     `10`     |
| LL (左ローテート) |     `11`     |

---

#### ■ B フィールド（3 ビット）

*B’ に格納されるのは下表の d の値*

|   B   | オペランド指定  | 説明                 |
| :---: | :------- | :----------------- |
| `000` | ACC      | アキュムレータを選択         |
| `001` | IX       | インデックスレジスタを選択      |
| `01-` | `d`      | 即値アドレス             |
| `100` | `[d]`    | 絶対アドレス（プログラム領域）    |
| `101` | `(d)`    | 絶対アドレス（データ領域）      |
| `110` | `[IX+d]` | IX 修飾アドレス（プログラム領域） |
| `111` | `(IX+d)` | IX 修飾アドレス（データ領域）   |

---

#### ■ bc : Branch Condition

|  略記 | b3 b2 b1 b0 | 条件式                          |
| :-: | :---------: | :--------------------------- |
|  A  |   0 0 0 0   | 常に成立                         |
|  VF |   1 0 0 0   | 桁あふれ `VF = 1`                |
|  NZ |   0 0 0 1   | `≠ 0` `ZF = 0`               |
|  Z  |   1 0 0 1   | `＝ 0` `ZF = 1`               |
|  ZP |   0 0 1 0   | `≥ 0` `NF = 0`               |
|  N  |   1 0 1 0   | `< 0` `NF = 1`               |
|  P  |   0 0 1 1   | `> 0` `(NF ⊕ ZF) = 0`        |
|  ZN |   1 0 1 1   | `≤ 0` `(NF ∨ ZF) = 1`        |
|  NI |   0 1 0 0   | `IBUF_FLG_IN = 0`            |
|  NO |   1 1 0 0   | `OBUF_FLG_IN = 1`            |
|  NC |   0 1 0 1   | `CF = 0`                     |
|  C  |   1 1 0 1   | `CF = 1`                     |
|  GE |   0 1 1 0   | `≥ 0` `(VF ⊕ NF) = 0`        |
|  LT |   1 1 1 0   | `< 0` `(VF ⊕ NF) = 1`        |
|  GT |   0 1 1 1   | `> 0` `((VF ⊕ NF) ∨ ZF) = 0` |
|  LE |   1 1 1 1   | `≤ 0` `((VF ⊕ NF) ∨ ZF) = 1` |

---

##### 凡例

* `×` = B’ フィールド不要
* `○` = 場合によっては B’ が必要
* `◎` = B’ フィールド必須

以上が PDF 中の表を Markdown で整形した内容です。
```

以下を **既存ドキュメントの末尾** にそのまま追記してください。
（前章までの構成を崩さないよう、章番号は振らず “付録” 的に挿入する想定です）

---

## フラグ更新規則（命令グループ別）

| 命令グループ                          |  CF |  VF |   NF  |   ZF  | 備考                                  |
| ------------------------------- | :-: | :-: | :---: | :---: | ----------------------------------- |
| **LD / ST**                     |  ―  |  ―  | **―** | **―** | データ転送のみ。演算を行わないため **一切のフラグを書き換えない** |
| **ADD / ADC**                   |  ◯  |  ◯  |   ◯   |   ◯   | 8 bit 加算結果に基づいて更新                   |
| **SUB / SBC / CMP**             |  ◯  |  ◯  |   ◯   |   ◯   | 減算または比較結果に基づいて更新                    |
| **論理演算** <br>(AND / OR / EOR)   |  ―  |  ―  |   ◯   |   ◯   | キャリ-あふれは発生しない                       |
| **シフト** <br>(SRA/SLA/SRL/SLL)   |  ◯  |  ―  |   ◯   |   ◯   | 右シフト時、落ちるビットを CF へ                  |
| **ローテート** <br>(RRA/RLA/RRL/RLL) |  ◯  |  ―  |   ◯   |   ◯   | 回転後の MSB→CF／CF→LSB の関係              |
| **IN / OUT**                    |  ―  |  ―  |   ―   |   ―   | I/O バッファ制御のみ                        |
| **RCF / SCF**                   |  ◯  |  ―  |   ―   |   ―   | CF を 0 / 1 に直値設定。他フラグ不変             |
| **JAL / JR / 分岐命令**             |  ―  |  ―  |   ―   |   ―   | 分岐条件の評価のみでフラグは変更しない                 |
| **NOP / HLT**                   |  ―  |  ―  |   ―   |   ―   | ―                                   |

> **凡例**：<br>◯ = 更新する　／　― = 変更しない

---

## 命令長と PC 自動更新ルール

|       B フィールド      | オペランド種別         |     命令長    | 実行後の PC       |
| :----------------: | :-------------- | :--------: | :------------ |
|    `000`, `001`    | レジスタ (ACC / IX) | **1 byte** | `PC ← PC + 1` |
| その他 (`01-`, `1--`) | 即値・絶対・IX 修飾     | **2 byte** | `PC ← PC + 2` |

*シミュレータでは `step()` 内部で上表の規則を判定し、デコード完了後に PC をインクリメントしている。
1 語命令をテストする場合、実行直後の `d` コマンドで `pc=0x1` になっているかを確認すること。*

---

### 追加参考事項

* **NF (Negative Flag)** は演算結果の **bit 7** と完全に一致する。算術・論理演算後に `NF ← result[7]`。
* **ZF (Zero Flag)** は演算結果が **0x00** かどうか。
* **CF / VF** の計算式は CPU2025.pdf **表 6「フラグ生成規則」** に準拠。
* I/O 命令 (`IN / OUT`) 実行時は **OBUF\_FLG\_IN / IBUF\_FLG\_IN** がハード側で自動制御されるが、シミュレータでは `OBUF`, `IBUF` 変数で模擬している。

---

これらを追加すれば、**「LD/ST がフラグを変更しない」** 点や **「命令長による PC 更新」** がドキュメント上でも明示され、実装・テストと仕様が齟齬なく対応づけられます。
